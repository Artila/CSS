## 边框内圆角

### 难题

有时我们需要一个容器，只在内侧有圆角，而边框或描边的四个角在外部仍然保持直角的形状。

这是一个有趣的效果，目前还没有被滥用。

用两个元素可以实现这个效果，这并没有什么特别的：

```css
<div class="something-meaningful">
  <div>
    I have a nice subtle inner rounding, don't I look pretty?
  </div>
</div>
/* 相当于最外层边框，padding 就是边框的宽度 */
.something-meaningful {
  background: #655;
  padding: .8em;
}

.something-meaningful>div {
  background: tan;
  border-radius: .8em;
  padding: 1em;
}
```

这个方法很好，但要求我们使用两个元素，而我们只需要一个元素。

有没有办法可以只用一个元素达成同样的效果呢？



### 解决方案

其实上述方案要更加灵活一些，因为它允许我们充分运用背景的能力。

举个例子，如果我们希望这一圈“边框”不只是纯色的，而是要加一层淡淡的纹理，它也可以很容易地做到。

不过，如果只需要达成简单的实色效果，那我们就还有另一条路可走，只需用到一个元素（但这个办法有一些 hack的味道）。

我们来看看以下 CSS 代码：

```css
background: tan;
border-radius: .8em;
padding: 1em;
box-shadow: 0 0 0 .6em #655;
outline: .6em solid #655;
```

你能猜到视觉效果是怎样的吗？

它产生的效果正如上面的代码的效果一样。

我们基本上受益于两个事实：描边并不会跟着元素的圆角走（因而显示出直角），但 box-shadow 却是会的。

因此，如果我们把这两者叠加到一起，box-shadow 会刚好填补描边和容器圆角之间的空隙，这两者的组合达成了我们想要的效果。

把投影和描边显示为不同的颜色，在视觉上会有更清晰的解释。

请注意，我们为 box-shadow 属性指定的扩张值并不一定等于描边的宽度，我们只需要指定一个足够填补“空隙”的扩张值就可以了。

事实上，指定一个等于描边宽度的扩张值在某些浏览器中可能会得到渲染异常，因此我
推荐一个稍小些的值。

这又引出了另一个问题：到底多大的投影扩张值可以填补这些空隙呢？

为了解答这个问题，我们需要回忆起中学时学过的勾股定理，用来计算直角三角形各边的长度。

勾股定理表明，如果直角边分别是 a 和 b，则斜边（正对着直角的最长边）等于$$ \sqrt{a^2 + b^2} $$。

当两条直角边的长度相等时，这个算式会演化为 $$ \sqrt{2a^2 } = a\sqrt{2} $$。

你可能还很纳闷，中学几何到底是怎么跟我们的内圆角效果扯上关系的？

关于怎样用它来计算我们需要的最小扩张值，请看解释。

![2-4](D:\Github\CSS\CSS SECRETS\第2章 背景与边框\2-4.PNG)

在我们的例子中，border-radius 是 .8em，那么最小的扩张值就是 $$ 0.8(\sqrt{2} - 1) ≈ 0.331 370 85 em ​$$。

我们要做的就是把它稍微向上取个整，把 .34em 设置为投影的扩张半径。

为了避免每次都要计算，你可以直接使用圆角半径的一半，因为 $$ \sqrt{2} - 1 < 0.5 $$。

请注意，该计算过程揭示了这个方法的另一个限制：为了让这个效果得以达成，扩张半径需要比描边的宽度值小，但它同时又要比$$ (\sqrt{2} - 1)r $$ 大（这里的 r 表示 border-radius）。

这意味着，如果描边的宽度比 $$ (\sqrt{2} - 1)r $$ 小，那我们是不可能用这个方法达成该效果的。

具体代码见 inner-rounding.html。



为什么说这个方法有点 hack 的味道？

因为它依赖于描边不跟着圆角走的这个事实，但我们无法保证这种行为是永远不变的。

当前的规范在描边的绘制方面给了浏览器非常多的余地，但根据 CSS 工作组最近的讨论来看，未来规范将会明确地建议描边跟着圆角走。

浏览器是否会遵从这个决定，我们到时候就知道了。