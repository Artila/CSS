## 扩大可点击区域

### 难题

对于那些较小的、难以瞄准的控件来说，如果不能把它的视觉尺寸直接放大，将其可点击区域（热区）向外扩张往往也可以带来可用性的提升。

随着触屏的不断普及，这一点变得愈发重要。

没有人愿意对一个狭小的按钮尝试点按很多次，但实际上这样的无奈之举仍然每天都在发生。

还有一些时候，我们想让某个元素在鼠标接近窗口某侧时自动滑入。

举个例子，一个自动隐藏的页头会在鼠标接近时自动从顶部滑入并完整展现，这也涉及（只在单一方向上）放大热区的问题。

只借助纯 CSS 可以做到这一点吗？



### 解决方案

假设有一个简单按钮，我们想将其热区在四个方向上均向外扩大 10px。

我们已经给它应用了一些简单的样式以及 `cursor:pointer`，它既可以为鼠标交互提供自释性（affordance），又可以帮助我们试探它的热区到底有多大范围。

（在可用性领域中，“自释性”是控件的一种属性，表示它能以视觉的方式来提示我们如何与
之进行交互。举例来说，一个按钮的立体感暗示着它可以被按下，一个门把手的形状就在引
导用户去拉动或旋动。）

扩张热区最简单的办法是为它设置一圈透明边框，因为鼠标对元素边框的交互也会触发鼠标事件，这一点是描边和投影所不及的。

就这个例子而言，把元素的热区在四个方向上各向外扩大 10px 其实很容易做到：

```css
border: 10px solid transparent;
```

可以看到，效果并不好，因为它同时让按钮变大了！

原因在于背景在默认情况下会蔓延到边框的下层。

简单好用的 background-clip属性可以把背景限制在原本的区域之内：

```css
border: 10px solid transparent;
background-clip: padding-box;
```

可以看到，这个方法很管用。

不过好景不长，当你需要给按钮加上真正的边框效果时，会发现按钮仅有的那道边框已经被我们挪作他用了。

怎么办？很简单，可以用内嵌投影来模拟出一道（实色）边框：

```css
border: 10px solid transparent;
box-shadow: 0 0 0 1px rgba(0,0,0,.3) inset;
background-clip: padding-box;
```



与边框不同的是，box-shadow 可以同时指定多层投影。

因此，如果你真的需要多层投影，只要指定多个由逗号分隔的投影即可。

但如果把内嵌投影和（常规的）外部投影组合起来，将会得到一个怪异的效果，因为外部投影是绘制在 border box 外部的。

比如，我们可能想给这个按钮再加一道真实的模糊化投影，来营造一种“浮出表面”的效果（这也是一种暗示可点击的自释性）：

```css
box-shadow: 0 0 0 1px rgba(0,0,0,.3) inset,
            0 .1em .2em -.05em rgba(0,0,0,.5);
```

不过，一旦真的这样去做，就会发现结果跟我们的期望大相径庭。

这个解决方案在其他方面也不够完美：边框会影响布局，而且在某些场景下我们可能根本无法利用边框。

那该怎么改进呢？

我们放弃边框，然后改用另外一个特性来实现：伪元素同样可以代表其宿主元素来响应鼠标交互。

我们可以在按钮的上层覆盖一层透明的伪元素，并让伪元素在四个方向上都比宿主元素大出 10px：

```css
button {
 position: relative;
 /* [其余样式] */
}
button::before {
 content: '';
 position: absolute;
 top: -10px; right: -10px;
 bottom: -10px; left: -10px;
} 
```

只要有任何一个伪元素可供利用，这个方法就可以发挥作用，也不会干扰其他任何效果。

这个基于伪元素的解决方案极为灵活，我们基本上可以把热区设置为任何想要的尺寸、位置或形状，甚至可以脱离元素原有的位置！