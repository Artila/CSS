## 通过阴影来弱化背景

### 难题

很多时候，我们需要通过一层半透明的遮罩层来把后面的一切整体调暗，以便凸显某个特定的 UI 元素，引导用户关注。

比如，弹出层以及交互式的“快速指南”就是这种效果的典型案例。

这个效果最常见的实现方法就是增加一个额外的 HTML 元素用于遮挡背景，然后为它添加如下样式：

```css
.overlay { /* 用于遮挡背景 */
 position: fixed;
 top: 0;
 right: 0;
 bottom: 0;
 left: 0;
 background: rgba(0,0,0,.8);
}
.lightbox { /* 需要吸引用户注意的元素 */
 position: absolute;
 z-index: 1;
 /* [其余样式] */
}
```

.overlay 遮罩层负责把这个关键元素背后的所有东西调暗。

.lightbox 需要指定一个更高的 z-index，以便绘制在遮罩层的上层。

这个方法稳定可靠，但需要增加一个额外的 HTML 元素，这意味着该效果无法由 CSS 单独实现。

这不是一个很严重的问题，但对我们来说又确实是个麻烦事。不过还好，有其他方法可以摆脱这个麻烦。



### 解决方案

#### 伪元素方案

我们可以用伪元素来消除额外的 HTML 元素，比如：

```css
body.dimmed::before {
 position: fixed;
 top: 0;
 right: 0;
 bottom: 0;
 left: 0;
 z-index: 1;
 background: rgba(0,0,0,.8);
}
```

这个办法确实有一定改善，因为我们可以直接在 CSS 层面使用这个效果了。

不过问题是，这个方法的可移植性还不够好，因为  元素上可能有其他需求已经占用了 `::before` 伪元素；

而且在使用这个效果时，我们往往还需要一点 JavaScript 来给  添加 dimmed 这个类。

如果把遮罩层交给这个元素自己的 ::before 伪元素来实现，就可以弥补这些不足了。

给伪元素设置 `z-index: -1;` 就可以让它出现在元素的背后。

尽管这解决了可移植性的问题，但无法对遮罩层的 Z 轴层次进行细粒度的控制。

它可能会出现在这个元素之后（这是我们期望的），但也可能会出现在这个元素的父元素或祖先元素之后。

这个方法还有一个问题，伪元素无法绑定独立的 JavaScript 事件处理函数。

当遮罩层是由一个独立的元素来实现时，我们可以给它绑定事件处理函数，比如当用户点击遮罩层时自动关闭弹出层。

当使用弹出层自己的伪元素来实现遮罩层时，就需要判断用户到底是点了弹出层还是遮罩层，这就变得相当棘手了。



#### box-shadow 方案

上述伪元素方案相对灵活一些，通常可以满足绝大多数人对遮罩层的期望。

但对于简单的应用场景和产品原型来说，我们可以利用 box-shadow 来达到调暗背景的效果：box-shadow 的扩张参数可以把元素的投影向各个方向延伸放大。

具体做法就是生成一个巨大的投影，不偏移也不模糊，简单而拙劣地模拟出遮罩层的效果：

```css
box-shadow: 0 0 0 999px rgba(0,0,0,.8);
```

这个初步的解决方案有一个明显的问题，就是它无法在较大的屏幕分辨率（>2000px）下正常工作。

我们要么加大数字来缓解这个问题，要么换用视口单位来一劳永逸地解决它，只有这样才能确保“遮罩层”总是可以覆盖（甚至超出）视口。

因为我们无法分开指定水平和垂直方向上的扩张半径，所以此处最合适的视口单位是 vmax。

也许你对 vmax 单位还不熟悉，这里简单介绍一下：1vmax 相当于 1vw 和 1vh 两者中的较大值。

100vw 等于整个视口的宽度，100vh 就是视口的高度。

因此，满足我们需求的最小值就是50vmax。

由于投影是同时向四个方向扩展的，这个遮罩层的最终尺寸将是100vmax 加上元素本身的尺寸。

```css
box-shadow: 0 0 0 50vmax rgba(0,0,0,.8);
```

这个技巧非常简洁易用，但它存在两个非常严重的问题，从而制约了其使用场景。

你能指出这两个问题分别在哪里吗？

第一，由于遮罩层的尺寸是与视口相关，而不是与页面相关的，当我们滚动页面时，遮罩层的边缘就露出来了，除非给它加上 `position: fixed;`这个样式，或者页面并没有长到需要滚动的程度。

此外，由于页面很可能真的很长，为了规避这个缺陷而扩大投影的扩张半径就不太明智了。

相反，我推荐有限度地应用这个技巧，比如配合固定定位来使用，或者当页面没有滚动条时再用。

第二，当使用一个独立的元素（或伪元素）来实现遮罩层时，这个遮罩层不仅可以从视觉上把用户的注意力引导到关键元素上，还可以防止用户的鼠标与页面的其他部分发生交互，因为遮罩层会捕获所有指针事件。

box-shadow并没有这种能力，因此它只能在视觉上起到引导注意力的作用，却无法阻止鼠标交互。

这一点是否可以接受，取决于你的具体需求。



#### backdrop 方案

如 果 你 想 引 导 用 户 关 注 的 元 素 就 是 一 个 模 态 的  元 素（ 元素可以由它的 showModal() 方法显示出来），那么根据浏览器的默认样式，它会自带一个遮罩层。

借助 `::backdrop` 伪元素，这个原生的遮罩层也是可以设置样式的，比如可以把它变得更暗一些：

```css
dialog::backdrop {
 background: rgba(0, 0, 0, .8);
}
```

这个方法唯一需要注意的地方在于，在编写本书时，浏览器对它的支持还极为有限。

在你使用之前，需要确认一下兼容性问题。

不过请记住，尽管浏览器还不支持它，对话框没有遮罩层也并不会导致任何功能缺失，因为它只是一种用户体验上的增强手段而已。