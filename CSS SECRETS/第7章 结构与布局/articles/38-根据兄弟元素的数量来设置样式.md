## 根据兄弟元素的数量来设置样式

### 难题

在某些场景下，我们需要根据兄弟元素的总数来为它们设置样式。

最常见的场景就是，当一个列表不断延长时，通过隐藏控件或压缩控件等方式来节省屏幕空间，以此提升用户体验。

下面列出了一些典型案例。

- 电子邮件列表或包含文本内容的类似列表。如果列表中只有少量列表项，我们可以为第一项展示出多行预览文字；当列表项不断增加时，需要逐渐减少每一项的预览行数；当列表的总长度超出整个视口的高度时，可能会把预览文字完全隐藏，并把按钮变小，以此避免用户对页面的滚动。


- 待办事项应用程序。当列表中的事项较少时，我们可以用一个较大的字号来显示所有事项；随着事项的数量不断增加，我们会不断减小字号来显示每个事项。


- 调色板应用程序，每个色块上都显示出配套的控件。当色块的数量不断增加时，它们所占据的空间也会相应增加，此时我们可能希望色块的控件变得紧凑一些（参见图 7-7）。


- 包含多个 `<textarea>` 元素的应用程序。每当我们添加一个新的`<textarea>` 元素，所有元素都会同步缩小（类似于 bytesizematters.com 的效果）。

不过，对 CSS 选择符来说，基于兄弟元素的总数来匹配元素并不简单。

设想一个列表，假设仅当列表项的总数为 4 时才对这些列表项设置样式。

我们可以用 li:nth-child(4)来选中列表的第四个列表项，但这并不是我们想要的；

我们需要在列表项的总数为 4 时选中每一个列表项。

（本节用到的都是 :nth-child() 选择符，但我们讨论的所有内容也适用于 :nth-of-type() 选择符，而且它在语义上往往更加贴切，因为在所有的兄弟元素中可能包含了不同的元素类型，而我们往往只关心同类型的元素。本节的示例用到的是列表项，但我们讨论的技巧同样适用于其他类型的元素。）

![38-1](E:\Github\CSS\CSS SECRETS\第7章 结构与布局\images\38-1.PNG)

接下来的想法可能就是把 :nth-child() 和兄弟选择符（ ~ ）结合起来，比如 li:nth-child(4), li:nth-child(4) ~ li 。

不过，这个选择符只能命中第四个列表项以及在它之后的所有列表项（参见图 7-8），这跟列表项的总数没有什么关系。

![38-2](E:\Github\CSS\CSS SECRETS\第7章 结构与布局\images\38-2.PNG)

由于并没有一种组合式选择符可以用“回头看”的方式选中之前的兄弟元素，那么这个任务对 CSS 来说就注定要失败了吗？

千万不要轻易放弃！



### 解决方案

对于只有一个列表项的特殊场景来说，解决方案显然就是 :only-child ，这个伪类选择符就是为这种情况而设计的。

它不仅可以成为一个很好的起点，而且这个属性在某些场景下确实可以派上用场，因此可以在规范中占有一席之地。

举例来说，在图 7-7 中你可以发现，当列表中只有一个列表项时，我们把删除按钮隐藏起来了；这个需求是可以由 `:only-child` 选择符来完成的：

```css
li:only-child {
	/* 只有一个列表项时的样式 */
}
```

实 际 上， `:only-child` 等 效 于 `:first-child:last-child` ， 道理很简单：如果第一项同时也是最后一项，那从逻辑上来说它就是唯一的那一项。 

`:last-child` 其实也是一个快捷写法，相当于 `:nth-last-child(1)` ：

```css
li:first-child:nth-last-child(1) {
	/* 相当于li:only-child */
}
```

这个 1 其实是一个参数，我们可以根据需要来修改这个值。

你能猜到 `li:first-child:nth-last-child(4)` 会命中哪些元素吗？

如果从 `:only-child` 的例子举一反三，认定这个选择符会在列表项总数为 4 时命中所有列表项，那你可就太过乐观了。

我们还没达到那个效果，但已经处在正确的方向上了。

让我们把这两个伪类分开来想一想：我们在找一个同时匹配 :first-child 和 :nth-last-child(4) 的元素。

因此，这个元素需要是父元素的第一个子元素，同时还需要是从后往前数的第四个子元素。

有哪个元素可以满足这个条件呢？

答案就是，一个正好有四个列表项的列表中的第一个列表项（参见图7-9）。

![38-3](E:\Github\CSS\CSS SECRETS\第7章 结构与布局\images\38-3.PNG)

这并不完全是我们想要的结果，但已经非常接近了。

我们现在已经找到一种命中特定数量列表项中第一项的方法，接下来就可以用兄弟选择符（ ~ ）来命中它之后的所有兄弟元素：相当于在这个列表正好包含四个列表项时，命中它的每一项，而这正是我们一直想要达成的目标：

```css
li:first-child:nth-last-child(4),
li:first-child:nth-last-child(4) ~ li {
	/* 当列表正好包含四项时，命中所有列表项 */
}
```

这个方法需要的代码还是相当冗长繁琐的。我们可以利用预处理器（比如 SCSS）来避免这个问题，不过现有预处理器的语法在处理这个需求时仍然有些笨拙：

```css
/* 定义mixin */
@mixin n-items($n) {
  &:first-child:nth-last-child(#{$n}),
  &:first-child:nth-last-child(#{$n}) ~ & {
  	@content;
  }
}
/* 调用时是这样的： */
li {
  @include n-items(4) {
  /* 属性与值写在这里 */
  }
}
```



#### 根据兄弟元素的数量范围来匹配元素

在实际的应用场景中，我们期望匹配元素的条件往往并不是列表项的具体数量，而是一个数量范围。

 :nth-child() 选择符在这方面非常好用，我们可以用它来命中一个范围，比如“选中第 4 项之后的所有项”这样的需求就完全不在话下。

它的参数不仅可以是简单的数字，也可以是像 an+b 这样的表达式（比如 :nth-child(2n+1) ）。

这里的 n 表示一个变量，理论上的范围是 0 到 + ∞（在实际情况下，由于页面中元素的数量本来就是有限的，超
过某个特定数量的值实际上也没有元素可选了）。

如果使用 n+b 这种形式的表达式（此时相当于 a 的取值为 1），那么不论 n 如何取值，这个表达式都
无法产生一个小于 b 的值。

因此， n+b 这种形式的表达式可以选中从第 b 个开始的所有子元素。

举例来说， :nth-child(n+4) 将会选中除了第一、二、三个子元素之外的所有子元素（参见图 7-10）。

![38-4](C:\Users\ztb_pm_zues\Desktop\38-4.PNG)

利用这个技巧，我们可以在列表项的总数是 4 或更多时选中所有列表项（参见图 7-11）。

![38-5](E:\Github\CSS\CSS SECRETS\第7章 结构与布局\images\38-5.PNG)

在这种情况下，我们可以把表达式 n+4 传给 :nth-last-child() ：

```css
li:first-child:nth-last-child(n+4),
li:first-child:nth-last-child(n+4) ~ li {
	/* 当列表至少包含四项时，命中所有列表项 */
}
```

同理， -n+b 这种形式的表达式可以选中开头的 b 个元素。

因此，仅当列表中有 4 个或更少的列表项时（参见图 7-12），要选中所有列表项可以这样写：

```css
li:first-child:nth-last-child(-n+4),
li:first-child:nth-last-child(-n+4) ~ li {
	/* 当列表最多包含四项时，命中所有列表项 */
}
```

![38-6](E:\Github\CSS\CSS SECRETS\第7章 结构与布局\images\38-6.PNG)

当然，我们还可以把这两种技巧组合起来使用，不过代码也会变得更加复杂。假设我们希望在列表包含 2 ～ 6 个列表项时命中所有的列表项，可以这样写：

```css
li:first-child:nth-last-child(n+2):nth-last-child(-n+6),
li:first-child:nth-last-child(n+2):nth-last-child(-n+6) ~ li {
	/* 当列表包含2～6项时，命中所有列表项 */
}
```



