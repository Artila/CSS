## 紧贴底部的页脚

### 难题

在网页设计中，存在一个相当古老但又相当常见的问题，它是前端工程师绕不开的坎。

这个问题可以简单地概括如下：有一个具有块级样式的页脚（比如它设置了背景或阴影），当页面内容足够长时它一切正常，而当页面较短时（比如错误信息页面）就会出现问题。

（具体来说，当页面内容的长度小于视口高度减去页脚高度时，这个问题就会出现。）

此时的问题在于，页脚不能像我们期望中那样“紧贴”在视口的最底部，而是紧跟在内容的下方。

这个问题不仅普遍存在，而且乍看起来确实相当简单。

因此，在所有“隐蔽大坑”式的难题中，它简直就是教科书般的典型案例。

不仅如此，CSS 2.1 基本上拿它没有办法：几乎所有的经典解决方案都需要给页脚设置固定的高度，而这显然是不健壮的，也是不实际的。

此外，所有这些解决方案都太过复杂、太像 hack 了，而且往往要求网页按照特定的结构来写。

在那个年代，受制于 CSS 2.1 有限的能力范围，这已是我们所能达到的最好结果了。

不过，在现代 CSS 的协助下，我们可以做得更好吗？

如果答案是肯定的，又该如何去做？



### 解决方案

#### 固定高度的解决方案

我们手头的这个页面极其简单， `<body>` 元素内的结构代码如下所示

```html
<header>
  <h1>Site name</h1>
</header>
<main>
  <p>Bacon Ipsum dolor sit amet...
  <!-- 从baconipsum.com那里复制一些示意文字过来 --></p>
</main>
<footer>
  <p>© 2015 No rights reserved.</p>
  <p>Made with ♥ by an anonymous pastafarian.</p>
</footer>
```

然后我们给页面加上一些基本样式，再给页脚加上一层背景。

你可以在图 7-23 中看到它的样子。

现在，让我们把页面内容缩短一些，结果如图7-24 所示。

![41-1](E:\Github\CSS\CSS SECRETS\第7章 结构与布局\images\41-1.PNG)

此时页脚沉不到底的问题就完全暴露出来了！

好吧，我们重现了这个问题，但是该如何解决呢？

假设这个页脚的文本永远不可能折行，那我们就可以推算出它实际所占的高度：

  2 行 × 行高 +3× 段落的垂直外边距 + 页脚的垂直内边距 = 2 × 1.5em + 3 × 1em + 1em = 7em。

同样，我们可以得出页头的高度是 2.5em 。

接下来，借助视口相关的长度单位以及 calc() 函数，只需一行 CSS 代码就可以表达出这种尺寸关系，从而把页脚“固定”到底部：

```css
main {
  min-height: calc(100vh - 2.5em - 7em);
  /* 避免内边距或边框搞乱高度的计算： */
  box-sizing: border-box;
}
```

或者换个方式，我们可以把 `<header>` 和 `<main>` 元素包在一个容器里，然后在算式中就只需要考虑页脚的高度了：

```css
wrapper {
  min-height: calc(100vh - 7em);
}
```

( 在 calc() 中使用加减法时要特别当心：记得在 + 和 - 运算符的左右各加一个空格。这条怪异的规则是为了向前兼容。在未来的某个时候， calc() 内部可能会允许使用关键字，那么 CSS 解析器就需要有依据来区分关键字中的连字符和减号运算符。 )

这个方法是有效的（参见图 7-25），而且它似乎比那些需要固定高度的方案还要稍好一些，主要好在它的代码极其精简。

不过，如果页面布局不是这么简单的话，那这个方法就完全不实用了。

它不仅要求我们确保页脚内的文本永远不会折行，而且每当我们改变页脚的尺寸时，都需要跟着调整 min-height 值（也就是说，这不够 DRY）；

此外，除非我们愿意给页头和内容主体套一层额外的 HTML 元素，否则还要跟着页头的尺寸修改。

想必在这个美好的新时代，我们还有更好的办法，对吗？

#### 更灵活的解决方案

Flexbox 对于此类问题同样是完美的选择。

只需寥寥几行 CSS 代码就可以完美达成十分灵活的布局效果，而且完全不需要复杂的计算或是添加多余的 HTML 元素等。

首先，我们需要对 <body> 元素设置 display: flex ，因为它是这三个主要区块的父元素，当父元素获得这个属性之后，就可以对其子元素触发“伸缩盒布局模型”。

我们还需要把 flex-flow 设置为 column ，否则子元素会被水平排放在一行上（参见图 7-26）：

```css
body {
  display: flex;
  flex-flow: column;
}
```
![41-2](E:\Github\CSS\CSS SECRETS\第7章 结构与布局\images\41-2.PNG)

此时，页面看起来与没有启用 Flexbox 的情况似乎是一样的，因为所有元素都占据了整个视口的宽度，而它们的高度也都是由其自身的内容来决定的。

也就是说，我们还没有真正发挥 Flexbox 的威力。

为了完全释放它的魔力，我们首先要把 `<body>` 的 min-height 属性指定为 100vh ，这样它就至少会占据整个视口的高度。

不过，现在整个页面的布局仍然跟图 7-24 无异，原因在于，虽然我们已经为整个 body 元素指定了最小高度，但各个子元素的高度仍然是以各自的内容为准的（按照 CSS 规范的说法，它们的高度仍然由内部因素来决定）。

此时我们所期望的是，页头和页脚的高度由其内部因素来决定，而内容区块的高度应该可以自动伸展并占满所有的可用空间。

我们只要给 `<main>` 这个容器的 flex 属性指定一个大于 0 的值（比如 1 即可），就可以实现这个效果了：

```css
body {
  display: flex;
  flex-flow: column;
  min-height: 100vh;
}
main { 
  flex: 1;
}
```

（这 个 flex 属 性 实 际 上 是 flex-grow 、 flex-shrink 和 flex-basis 的简写语法。任何元素只要设置了一个大于 0 的flex 值，就将获得可伸缩的特性； flex 的值负责控制多个可伸缩元素之间的尺寸分配比例。举例来说，在我们眼前的这个例子中， 如 果 `<main>` 是 flex: 2 而 `<footer>` 是 flex: 1 ，那么内容区块的高度将是页脚高度的两倍。如果把它们的值从 2 和 1 改为 4和 2 ，结果也是一样的，因为真正起作用的是它们的数值比例。）

这样就可以了！我们只需要四行简单的代码，就完美实现了紧贴底部的页脚（与图 7-25 中的效果一致）。

Flexbox 是不是相当霸气？