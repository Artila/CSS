## 满幅的背景，定宽的内容

### 难题

在过去的几年间，有一种网页设计手法逐渐流行起来，我将它称作背景宽度满幅，内容宽度固定。

这个设计的一些典型特征如下。

- 页面中包含多个大区块，每个区块都占据了整个视口的宽度，区块的背景也各不相同。


-  内容是定宽的，即使在不同分辨率下的宽度不一样，那也只是因为媒体查询改变了这个固定的宽度值而已。在某些情况下，不同区块的内容也可能具有不同的宽度。

有时候，整个网页都是由这种风格的多个区块组成的（比如图 7-13，或者像图 7-14 那样稍微含蓄一些）。

![39-1](E:\Github\CSS\CSS SECRETS\第7章 结构与布局\images\39-1.PNG)

![39-2](E:\Github\CSS\CSS SECRETS\第7章 结构与布局\images\39-2.PNG)

不过在更多的情况下，页面中只有某个特定区域是以这个风格来设计的，最典型的就是页脚（参见图 7-15）。

![39-3](E:\Github\CSS\CSS SECRETS\第7章 结构与布局\images\39-3.PNG)

要实现这种设计风格，最常见的方法就是为每个区块准备两层元素：外层用来实现满幅的背景，内层用来实现定宽的内容。

后者是通过 `margin: auto` 实现水平居中的。

举例来说，采用这种设计的页脚通常需要把结构代码写成：

```html
<footer>
  <div class="wrapper">
  	<!-- 页脚的内容写在这里 -->
  </div>
</footer>
```

同时用 CSS 来设置这两层元素的样式：

```css
footer {
	background: #333;
}
.wrapper {
	max-width: 900px;
	margin: 1em auto;
}
```

看起来很眼熟对不对？

目前绝大多数的网页设计师 / 工程师都是这样写的。

难道为了这个效果就一定要添加一层额外的元素？

我们能否在现代 CSS的帮助下彻底抛弃这个累赘？



### 解决方案

我们先来想一想， `margin: auto` 在这个场景下到底发挥了什么作用。

这条声明所产生的左右外边距实际上都等于视口宽度的一半减去内容宽度的一半。

由于百分比在这里是基于视口宽度来解析的（假设所有祖先元素都没有显式指定宽度），我们可以把这个外边距的值表达为 50% - 450px 。

实际上，CSS 值与单位（第三版）（http://w3.org/TR/css-values-3/#calc）定义了一个 calc() 函数，它允许我们在 CSS 中直接以这种简单的算式来指定属性的值。

如果用 calc() 取代原先的 auto ，这个内层容器的样式就会变成：

```css
.wrapper {
	max-width: 900px;
	margin: 1em calc(50% - 450px);
}
```

之所以要在页脚内加一层容器元素，唯一的原因就是为了给它的 margin 指定神奇的 auto 关键字，从而实现内容的水平居中布局。

不过，现在我们已经用 calc() 替代了这个神奇的 auto ，而且这个新值实际上可以作为一个通用的 CSS 长度值应用到任何一个接受长度值的属性上。

（别忘了在 calc() 函数中用空白符把 - 和 + 隔起来，否则会产生解析错误！这个看似怪异的规则是为了向前兼容：在未来，calc() 可能会允许使用标识符，而这些标识符本身可能会包含连字符，容易与减号混淆。）

这意味着如果我们愿意，还可以把这个长度值应用到父元素的 padding 上，而整个效果是保持不变的：

```css
footer {
  max-width: 900px;
  padding: 1em calc(50% - 450px);
  background: #333;
}
.wrapper {}
```

如你所见，经过这一番改造之后，我们已经把内层容器上的所有 CSS代码都剥离干净了。

也就是说，它其实已经不需要参与布局了，我们可以安全地把它从结构代码中去掉。

终于，我们在纯净无冗余的 HTML 结构上实现了想要的设计风格。这个方案还有进一步优化的空间吗？

没错。

你要相信，追求卓越的道路是永无止境的！

如果把 width 这一行声明注释掉，你会发现其实没有影响。

视觉效果是完全一样的，而且不论视口尺寸如何变化都是如此。

这是为什么呢？

因为当内边距是 50% - 450px 时，只可能给内容留出 900px （2× 450px ）的可用空
间。

只有把 width 显式地设置为 900px 之外（或大或小）的其他值，我们才有可能看出区别。

由于我们想要得到的内容宽度本来就是 900px ，这一行声明其实就是冗余的，我们可以把它去掉，让代码更加 DRY。

另一个可以优化的地方在于，我们可以增加一条回退样式来增强向后兼容性。

这样即使浏览器不支持 calc() ，我们也至少可以得到一个相对合理的内边距：

```css
footer {
  padding: 1em;
  padding: 1em calc(50% - 450px);
  background: #333;
}
```

终于大功告成了。

我们抛弃了冗余的标签，花费了三行 CSS 代码，最终达成了这个完美的结果：样式灵活、代码简练，还具有良好的兼容性！

（如果屏幕的宽度比内容的宽度还要窄，这个解决方案所产生的效果就是没有内边距！不过别急，我们可以用媒体查询来修复这个问题。）