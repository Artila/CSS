## 缓动效果

### 难题

给过渡和动画加上缓动效果（比如具有回弹效果的过渡过程）是一种流行的表现手法，可以让界面显得更加生动和真实：在现实世界中，物体从 A 点到 B 点的移动往往不是完全匀速的。

以纯技术的角度来看，回弹效果是指当一个过渡达到最终值时，往回倒一点，然后再次回到最终值，如此往复一次或多次，并逐渐收敛，最终稳定在最终值。

举个例子，假设要用一个元素来模拟一个下落的小球（参见图 8-1），我们会把 transform 属性 从 none 过渡到 translateY(350px) 来模拟这个下落过程。

（为什么在这里采用变形属性来表现物体的下落，而不是类似 top 或 margin-top 这样的属性？在编写本书时，变形属性的动画过程更加流畅；而其他 CSS 属性由于需要对齐到像素，往往略显生硬。）

实际上，回弹效果并不只对位移动画有帮助。

对几乎所有类型的过渡动画来说，它都可以显著增强动画的体验，其中包括：

* 尺寸变化（比如：元素在 :hover 时变大，弹出框从 transform:scale(0) 的状态开始放大显示，柱状图中的每根柱子动态地冒出来，等等）
* 角度变化（比如：元素的旋转动作，饼图中的各个扇区以动画的方式从 0° 开始展开为实际大小，等等）有相当多的 JavaScript 类库可以创建动画，且内置回弹效果。

但在眼下，我们其实已经不需要借助脚本来实现过渡和动画了。

不过，在 CSS 中实现回弹效果的最佳方式是什么呢？

### 解决方案

#### 弹跳动画

我们的第一感觉可能就是使用 CSS 动画，并设置如下关键帧：

```
@keyframes bounce {
    60%, 80%, to { transform: translateY(350px); }
    70% { transform: translateY(250px); }
    90% { transform: translateY(300px); }
}
.ball {
    /* 尺寸样式、颜色样式等 */
    animation: bounce 3s;
}
```

这段代码所描述的关键帧正好对应了图 8-1 中的每一个阶段。

但是，如果你跑一遍这个动画，会发现它显得很不真实。

主要原因在于，每当这个小球改变运动方向时，它的移动过程都是持续加速的，这看起来很不自然。

产生这个结果的原因在于，它的调速函数在所有关键帧的衔接中都是一样的。

你可能会问：“它的调速……什么？”

所有过渡和动画都是跟一条曲线有关的，这条曲线指定了动画过程在整段时间中是如何推进的（它在某些语境下也被称作“缓动曲线”）。

如果不指定调速函数，它就会得到一个默认值。

这个默认的缓动效果并不是我们想像中的匀速效果，而是如图 8-2 所示。

请注意（图 8-2 中粉色圆点所在的位置），当时间进行到一半时，这个过渡已经推进到 80% 了！

不论是在 animation / transition 简写属性中，还是在 animation-timing-function / transition-timing-function 展开式属性中，你都可以把这个默认的调速函数显式指定为 ease 关键字。

不过，由于 ease 本来就是默认值，这样做并没有什么实际用处。

除此以外，还有四种内置的缓动曲线（如图 8-3 所示），你可以用它们来改变动画的推进方式。

如你所见， ease-out 是 ease-in 是反向版本。

这一对组合正好是实现回弹效果所需要的：每当小球的运动方向相反时，我们希望调速函数也是相反的。

因此，我们可以在 animation 属性中指定一个通用的调速函数，然后在关键帧中按需覆盖它。

我们希望下落方向上的调速函数是加速的（ ease-out ），而弹起方向上是减速的（ ease-in ）：

```
@keyframes bounce {
    60%, 80%, to {
        transform: translateY(400px);
        animation-timing-function: ease-out;
    }
    70% { transform: translateY(300px); }
    90% { transform: translateY(360px); }
}
.ball {
    /* 其余样式写在这里 */
    animation: bounce 3s ease-in;
}
```
如果你试着运行这段代码，就会发现，虽然这个改动很小，但明显让回弹效果变得真实起来。

不过，这五种内置的缓动曲线明显不够用。

如果我们可以按照自己的需要来选择任意的调速函数，那应该可以实现更加真实的效果。

举个例子，如果这个回弹动画是用来模拟自由落体的，那么一个更高的加速度（类似 ease 所提供的效果）应该可以产生出一种更加真实的效果。

不过，如果没有对应的关键字可用，要如何得到 ease 的反向版本呢？

所有这五种曲线都是通过（三次）贝塞尔曲线来指定的。

我们可以在任意一种矢量绘图软件（比如 Adobe Illustrator）中处理贝塞尔曲线。

这种曲线由一定数量的路径片断所组成，各个片断的每一端都可以由一个手柄来控制曲率（这些手柄通常也被称作控制锚点）。

一条复杂的曲线可能包含很多个片断，这些片断的端点彼此相连构成了整条曲线（参见图 8-4）。

但 CSS 的调速函数都是只有一个片断的贝塞尔曲线，因此每个调速函数只有两个控制锚点。

举个例子，你可以在图 8-5 中看到默认调速函数（ ease ）以及它的控制锚点。

作为对上述五种预定义曲线的补充，CSS 提供了一个 cubic-bezier()函数，允许我们指定自定义的调速函数。

它接受四个参数，分别代表两个控制锚点的坐标值，我们通过这两个控制锚点来指定想要的贝塞尔曲线。

语法形式是这样的： cubic-bezier(x1, y1, x2, y2) ，其中 (x 1 , y 1 ) 表示第一个控制锚点的坐标，而 (x 2 , y 2 ) 是第二个。

曲线片断的两个端点分别固定在(0,0) 和 (1,1) ，前者是整个过渡的起点（时间进度为零，动画进度为零），后者是终点（时间进度为 100动画进度为 100%）。

请注意，固定曲线的两个端点并不是唯一的限制。

另外，两个控制锚点的 x 值都被限制在 [0, 1] 区间内（即我们无法把手柄在水平方向上移出这个图形范围）。

这个限制并不是随便加上的。由于我们（目前）无法穿越时间，因此无法指定这样一个过渡：在被触发之前就开始了，或者在时间用完之后仍然没有结束。

这里真正的限制是节点的数量：曲线只能有两个节点，这明显限制了它的能力，但也让 cubic-bezier() 函数易于使用。

尽管这些限制确实存在，但 cubic-bezier() 所能创造出的可能性已经相当可观了。

从逻辑上来说，只要我们把控制锚点的水平坐标和垂直坐标互换，就可以得到任何调速函数的反向版本。

这一点对关键字也是适用的；

上述所有五个关键字都有其对应的 cubic-bezier() 形式的值。

举例来说， ease 等同于 cubic-bezier(.25,.1,.25,1) ，因此它的反向版本就是 cubic-
bezier(.1,.25,1,.25) ，如图 8-6 所示。

通过这种方法，我们的回弹动画就可以使用 ease 了，并且看起来更加真实：

```
@keyframes bounce {
    60%, 80%, to {
        transform: translateY(400px);
        animation-timing-function: ease;
    }
    70% { transform: translateY(300px); }
    90% { transform: translateY(360px); }
}
.ball {
    /* 外观样式 */
    animation: bounce 3s cubic-bezier(.1,.25,1,.25);`
}
```
借助一款类似 cubic-bezier.com 的图形化工具（参见图 8-7），我们可以反复尝试和优化，从而进一步改进这个回弹动画。


#### 弹性过渡

假设有一个文本输入框，每当它被聚焦时，都需要展示一个提示框。

这个提示框用来向用户提供帮助信息，比如字段值的正确格式等。

结构代码可能是这样的：

```
<label>
    Your username: <input id="username" />
    <span class="callout">Only letters, numbers,underscores (_) and hyphens (-) allowed!</span>
</label>
```

触发这个提示框（ .callout ）所需要的 CSS 代码如下所示（我们在这里略去了具体的外观和布局样式）：

```
input:not(:focus) + .callout {
    transform: scale(0);
}
.callout {
    transition: .5s transform;
    transform-origin: 1.4em -.4em;
}
```

目前，当用户聚焦到这个文本输入框时，会有一个半秒钟的过渡，如图 8-8 所示。

这个过渡没有什么问题，但如果它在结尾时能再夸张一点的话，会显得更加自然和生动（比如说，先扩大到 110% 的尺寸，然后再缩回100%）。

我们可以把这个过渡改成一个动画，然后用上我们在前一段所学到的东西：

```
@keyframes elastic-grow {
    from { transform: scale(0); }
    70% {
        transform: scale(1.1);
        animation-timing-function:
        cubic-bezier(.1,.25,1,.25); /* 反向的ease */
    }
}
input:not(:focus) + .callout { 
    transform: scale(0); 
}
input:focus + .callout { 
    animation: elastic-grow .5s; 
}
.callout { 
    transform-origin: 1.4em -.4em; 
}
```

动手尝试之后，我们就会看到这个改动确实发挥了作用。你可以在图8-9 中看到它的效果，不妨与前一个过渡对比一下。不过，这里其实只是需要一个过渡而已，而我们本质上使用了一个动画。动画确实更加强大，但在
这个场景中，我们所需要的其实只是给这个过渡加入一些弹性的感觉，因此动画在这里显得大材小用了，有一种杀鸡用牛刀的感觉。有没有可能只用过渡就做出这个效果呢？这个问题的解决方案仍然来自于自定义调速函数 cubic-bezier() 。到目前为止，我们只是讨论了曲线的控制锚点处在 0~1 区间内的情况。前面
曾经提到过，我们无法在水平方向上超越这个范围，至少在时光机发明之前是不可能的；但我们可以在垂直方向上突破 0~1 区间，从而让过渡达到低于 0 或高于 100% 的程度。你能猜到这意味着什么吗？它表示如果我们要从scale(0) 的变形程度过渡到 scale(1) ，就还将经历一个比最终值更大的状态，比如 scale(1.1) （或者更甚，这取决于调速函数有多陡）。在这个例子中，我们只想加入一点弹性效果，因此希望调速函数可以先达到 110% 的程度（相当于 scale(1.1) ），然后再过渡回 100%。让我们从初始的调速函数 ease （ cubic-bezier(.25,.1,.25,1) ）开始，然后把第二个控制锚点向上移，直至调到类似 cubic-bezier(.25,.1,.3,1.5) 的程度。在图 8-10 中可以看到，现在这个过渡会在总时长 50% 的时间点达到 100%的变形程度。不过，过渡过程并不会停在那里；它会在超越最终值之后继续推进，在 70% 的时间点达到 110% 的变形程度峰值，然后在最后可用的30% 时间里过渡回它的最终值。可见，整个过渡的推进过程非常接近前面的动画方案，但它只需要一行代码就可以实现整个效果。我们把代码列在下面，作为对比：

```
input:not(:focus) + .callout { 
    transform: scale(0); 
}
.callout {
    transform-origin: 1.4em -.4em;
    transition: .5s cubic-bezier(.25,.1,.3,1.5);
}
```